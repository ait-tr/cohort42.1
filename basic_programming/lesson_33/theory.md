## Java Collections Framework

**Java Collections Framework** (JCF) - это архитектура в Java, которая предоставляет структуры данных и алгоритмы для работы с коллекциями. 
JCF входит в состав Java Standard Edition и содержит набор интерфейсов и их реализаций, которые облегчают разработку программного обеспечения, 
работающего с группами объектов.

**Коллекция** в Java (и в программировании в целом) - это объект, который группирует множество элементов в одном контейнере. 
В Java коллекции используются для хранения, управления, получения  и обработки данных в виде группы объектов.

Коллекции облегчают организацию данных и манипулирование ими, предоставляя структурированный и удобный способ работы с группами объектов.

Все коллекции в Java являются параметризованными, что означает, что они могут работать с элементами любого ссылочного типа данных. 
Параметризация коллекций позволяет задать конкретный тип данных, с которым будет работать коллекция, что обеспечивает типобезопасность 
и избавляет от необходимости приведения типов при извлечении элементов из коллекции.

```
List<String> strings = new ArrayList<>();  // коллекция для строк
List<Integer> integers = new LinkedList<>();  // коллекция для целых чисел
```

В этом примере `strings` может содержать только строки, а `integers` - только целые числа. Если попытаться добавить элемент другого типа, 
то компилятор выдаст ошибку.

Java Collections Framework (JCF) предоставляет несколько видов коллекций, каждый из которых имеет свои особенности:

- **Списки (List)**: упорядоченные коллекции, которые поддерживают дубликаты и обеспечивают доступ к элементам по индексу.
- **Множества (Set)**: неупорядоченные коллекции, не поддерживающие дубликаты.
- **Очереди (Queue)**: коллекции, обеспечивающие упорядоченное хранение элементов в порядке их добавления.
- **Карты (Map)**: коллекции, хранящие данные в виде пар "ключ-значение".

Таким образом, коллекция в Java - это структура данных, которая позволяет группировать объекты и работать с ними как с единой сущностью.

<img src="https://raw.githubusercontent.com/ait-tr/cohort42.1/main/basic_programming/lesson_33/img/CollectionSB.jpeg" width="100%">

### Основные интерфейсы и их реализации в JCF:

#### Интерфейсы:

- `Collection`: базовый интерфейс для всех коллекций.
- `List`: интерфейс для упорядоченных коллекций, поддерживающих дубликаты. Реализации: `ArrayList`, `LinkedList`, `Vector`.
- `Set`: интерфейс для наборов уникальных элементов. Реализации: `HashSet`, `LinkedHashSet`, `TreeSet`.
- `SortedSet`: интерфейс для сортированных наборов.
- `Queue`: интерфейс для очередей. Реализации: `LinkedList`, `PriorityQueue`.
- `Deque`: интерфейс для двусторонних очередей. Реализации: `LinkedList`, `ArrayDeque`.
- `Map`: интерфейс для коллекций пар "ключ-значение". Реализации: `HashMap`, `LinkedHashMap`, `TreeMap`.
- `SortedMap`: интерфейс для сортированных карт.

#### Реализации:

- `ArrayList` - базируется на массиве, обеспечивает быстрый доступ по индексу.
- `LinkedList` - базируется на двусвязном списке, обеспечивает быстрое добавление/удаление элементов.
- `Vector` - аналогичен `ArrayList`, но синхронизирован.
- `HashSet` - обеспечивает быстрый доступ к элементам, порядок следования не гарантирован.
- `LinkedHashSet` - сохраняет порядок добавления элементов.
- `TreeSet` - хранит элементы в отсортированном порядке.
- `PriorityQueue` - организует элементы в порядке приоритета.
- `ArrayDeque` - быстрое добавление/удаление элементов с обеих сторон очереди.
- `HashMap` - быстрый доступ к элементам, порядок следования не гарантирован.
- `LinkedHashMap` - сохраняет порядок добавления элементов.
- `TreeMap` - хранит элементы в отсортированном порядке.

#### Алгоритмы:

- JCF предоставляет стандартные алгоритмы для сортировки, поиска и перестановки элементов коллекций.
  Класс `Collections`, который предоставляет статические методы для работы с коллекциями. Эти методы включают алгоритмы сортировки, 
  поиска и перестановки элементов. Вот несколько примеров:

#### Синхронизация и неизменяемость:
- Для поддержки многопоточных операций в JCF есть синхронизированные обертки для коллекций и методы для создания неизменяемых коллекций.
  Большинство реализаций коллекций в Java Collections Framework не являются потокобезопасными, то есть не гарантируют корректное поведение 
  при использовании из нескольких потоков одновременно. Однако для обеспечения потокобезопасности, в Java есть специальные методы, которые 
  позволяют создавать синхронизированные обертки над коллекциями.

Примеры создания синхронизированных коллекций:

```
List<String> list = Collections.synchronizedList(new ArrayList<String>());
Set<String> set = Collections.synchronizedSet(new HashSet<String>());
Map<String, String> map = Collections.synchronizedMap(new HashMap<String, String>());
```

Что касается неизменяемости, то в Java есть методы, которые позволяют создать неизменяемые (immutable) коллекции. 
Это означает, что после создания такой коллекции, ее содержимое не может быть изменено. Пример создания неизменяемого списка:

```
List<String> list = Collections.unmodifiableList(new ArrayList<String>(Arrays.asList("a", "b", "c")));
```
Попытка добавить или удалить элемент из неизменяемой коллекции приведет к выбросу исключения `UnsupportedOperationException`.

Выбор конкретной реализации коллекции в JCF зависит от требований к производительности, порядку элементов и других факторов, специфичных для конкретной задачи.

### Итераторы

Итераторы играют ключевую роль в JCF, предоставляя способ обхода элементов коллекции. 
Интерфейс `Iterator` позволяет проходить по коллекции, не раскрывая её внутреннее представление. 
Расширенный интерфейс `ListIterator` добавляет возможность итерации в обоих направлениях и возможность модифицировать элементы при обходе.

### Конкурентные коллекции

Для многопоточных приложений важным дополнением к JCF являются конкурентные коллекции, находящиеся в пакете `java.util.concurrent`. 
Эти коллекции, такие как `ConcurrentHashMap`, `CopyOnWriteArrayList` и `BlockingQueue`, разработаны для использования в многопоточном контексте 
и помогают избежать проблем с синхронизацией и блокировками.

### Производительность

Выбор конкретной реализации коллекции может зависеть от требований к производительности. 
Например, `ArrayList` предпочтительнее, если часто нужен быстрый доступ по индексу, 
а `LinkedList` - если требуется частая вставка и удаление элементов.

### Синхронизация

Несмотря на то, что некоторые старые коллекции, такие как `Vector` и `Stack`, являются синхронизированными, 
для современных многопоточных приложений рекомендуется использовать конкурентные коллекции из пакета `java.util.concurrent`. 
Для обычных коллекций также можно использовать обёртки из классов `Collections.synchronizedList`, `Collections.synchronizedSet` 
и т.д., чтобы добавить базовую синхронизацию.

### Заключение

Java Collections Framework обеспечивает мощные инструменты для работы с данными в коллекциях, способствуя написанию более чистого, эффективного и масштабируемого кода. 
Благодаря широкому спектру реализаций, JCF может удовлетворить различные потребности в разработке программного обеспечения на Java.
