## Перечисления в Java (Enums)

### Что такое перечисления (Enums)?

- Специальный тип данных, который позволяет переменной быть набором предварительно определенных значений.

**Основная цель Enums:**
- Обеспечивать типобезопасность и снижать количество ошибок.

---

### Создание Enums:
```
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
}
```

### Использование Enums:
```
Day today = Day.MONDAY;
switch(today) {
    case MONDAY:
        System.out.println("Today is Monday.");
        break;
    // ... другие дни
}
```

---

## 3. Продвинутые возможности Enums

### Конструкторы и методы:
```
public enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6);
    // ... другие планеты

    private final double mass;
    private final double radius;

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    public double getMass() {
        return mass;
    }

    public double getRadius() {
        return radius;
    }
}
```

### Встроенные методы:
- `values()`: Возвращает массив, содержащий список констант Enum.
- `valueOf(String name)`: Возвращает константу Enum с указанным именем.

### Перечисление через цикл:
```
for (Day day : Day.values()) {
    System.out.println(day);
}
```

---

## 4. Сравнение Enums

### Сравнение с использованием `==` и `equals()`:
- Для сравнения двух значений Enum можно безопасно использовать оператор `==`.

### Метод `ordinal()`:
- Возвращает порядковый номер константы (начиная с нуля).

---

### EnumSet:
- Специализированный набор для работы с enums.
```
EnumSet<Day> weekend = EnumSet.of(Day.SATURDAY, Day.SUNDAY);
```

### EnumMap:
- Специализированная карта для ключей типа Enum.
```
EnumMap<Day, String> dayActivityMap = new EnumMap<>(Day.class);
dayActivityMap.put(Day.MONDAY, "Work");
```

---

### Преимущества использования Enums:
- Типобезопасность.
- Читаемость кода.
- Возможность группировки связанных констант.

## Обобщения (Generics)

Дженерики (обобщения) — это особые средства языка Java для реализации обобщённого программирования: особого подхода к описанию данных и алгоритмов, позволяющего работать с различными типами данных без изменения их описания.
На сайте Oracle дженерикам посвящён отдельный tutorial: [Oracle](https://docs.oracle.com/javase/tutorial/java/generics/index.html "Generics tutorial")

Обобщения или generics (обобщенные типы и методы) позволяют нам уйти от жесткого определения используемых типов.

Дженерики позволяют создавать классы, интерфейсы и методы, работающие с разными типами данных.

- Обобщенные классы.
Пример: class Box<T> { private T content; ... }
- Обобщенные интерфейсы.
Пример: interface List<T> { void add(T item); T get(int index); }
- Обобщенные методы.
```
    public <T> void printArray(T[] array) {
    for (T item : array) {
    System.out.println(item);
    }
    }
```

- Параметризация типами

```
public class GenericBox<T> {}
...
GenericBox<Integer> integerBox = new GenericBox<>;

```

При создании объекта класса после имени класса в угловых скобках нужно указать, какой именно тип будет использоваться вместо универсального параметра.
При этом надо учитывать, что они **работают только с объектами**, но не работают с примитивными типами.
То есть мы можем написать <Integer>, но не можем использовать тип int или double.
Вместо примитивных типов надо использовать классы-обертки: Integer вместо int, Double вместо double и т.д.


### Ограничения дженериков:

- Использование extends для ограничения типов.
Пример: `class NumericBox<T extends Number> { ... }`

- Использование super для ограничения типов.
Применяется в основном с `wildcards`.
Wildcards: ?, `? extends T`, `? super T`.

Пример: 
```
void processBoxes(List<? extends Fruit> boxes) { ... }
```

### Особенности работы с дженериками

- Erasure типов: что происходит во время компиляции.
Во время выполнения информация о типах удаляется, и `List<Integer>` становится просто `List`.

- Невозможность создания экземпляров обобщенного типа.
Пример: T item = new T(); // Ошибка

### Преимущества и недостатки использования дженериков.
  - Преимущества: безопасность типов, переиспользование кода, улучшенная читаемость кода.
  - Недостатки: сложность, ограничения на использование с примитивами, сложности при работе с массивами обобщенных типов.

<hr>

## Wrappers

Классы-обертки в Java используются для представления примитивных типов данных как объектов. Примитивные типы данных в Java, такие как `int`, `char` и `double`, не являются объектами. Однако иногда требуется работать с примитивами как с объектами, например, при добавлении их в коллекции или при использовании методов, ожидающих объекты.

Вот список классов-оберток для примитивных типов:

1. `Byte` - обертка для `byte`
2. `Short` - обертка для `short`
3. `Integer` - обертка для `int`
4. `Long` - обертка для `long`
5. `Float` - обертка для `float`
6. `Double` - обертка для `double`
7. `Character` - обертка для `char`
8. `Boolean` - обертка для `boolean`

Основные причины использования классов-оберток:

1. **Добавление в коллекции**: Примитивы напрямую не могут быть добавлены в коллекции, такие как `ArrayList`. С помощью классов-оберток их можно добавить как объекты.

2. **Методы и константы**: Классы-обертки предоставляют ряд полезных методов и констант для работы с соответствующими примитивами. Например, `Integer` предоставляет метод `parseInt` для преобразования строки в целое число.

3. **Поддержка `null`**: Примитивные типы не могут принимать значение `null`, в то время как их обертки могут. Это может быть полезно в некоторых случаях, чтобы отличить "отсутствующее" значение от любого конкретного значения примитива.

4. **Приведение типов**: Автоупаковка и автораспаковка в Java позволяют автоматически конвертировать примитивы в их обертки и наоборот.

Пример автоупаковки и автораспаковки:

```
Integer wrappedInt = 5;  // автоупаковка
int primitiveInt = wrappedInt;  // автораспаковка
```

Однако следует быть осторожным при работе с классами-обертками из-за возможных проблем с производительностью и неожиданным поведением, связанным с автоупаковкой и автораспаковкой.



Особенности работы с классами-обертками, связанные с автоупаковкой и автораспаковкой, могут проявляться в следующих условиях:

1. **Сравнение объектов с использованием `==`**: При использовании оператора `==` для сравнения двух объектов классов-оберток, сравниваются их ссылки, а не их значения. Это может привести к неожиданным результатам, особенно когда используется автоупаковка.

   ```
   Integer a = 127;
   Integer b = 127;
   System.out.println(a == b); // true

   Integer c = 128;
   Integer d = 128;
   System.out.println(c == d); // false
   ```

   В приведенном выше примере для значений от -128 до 127 используются кешированные объекты, поэтому `a` и `b` ссылаются на один и тот же объект. Однако для значений вне этого диапазона создаются новые объекты, и `c` и `d` являются разными объектами.

2. **Производительность**: Автоупаковка и автораспаковка добавляют накладные расходы, так как каждый раз создается новый объект. В циклах или интенсивных вычислениях это может существенно снизить производительность.

Общие (или схожие) методы, которыми обладают классы-обертки:

1. **`valueOf()`**: Преобразует данный тип (обычно строку или примитив) в соответствующий объект класса-обертки.

2. **`parseXxx()`**: Преобразует строку в соответствующий примитивный тип. Например, `Integer.parseInt()` или `Double.parseDouble()`.

3. **`toString()`**: Возвращает строковое представление значения объекта.

4. **`equals(Object obj)`**: Сравнивает текущий объект с указанным объектом на равенство.

5. **`compareTo()`**: Сравнивает текущий объект с другим объектом того же типа.

6. **`XxxValue()`**: Возвращает значение объекта как примитивный тип. Например, `intValue()` для `Integer` или `doubleValue()` для `Double`.

Это общие методы, но стоит отметить, что у каждого класса-обертки могут быть и свои уникальные методы, связанные с особенностями данного примитивного типа.
Все числовые обертки над примитивами в Java наследуются от абстрактного класса `Number`. Это включает в себя следующие классы:

- `Byte`
- `Short`
- `Integer`
- `Long`
- `Float`
- `Double`

Эти классы обладают методами, унаследованными от `Number`, которые позволяют извлекать значение объекта в различных примитивных форматах. К таким методам относятся:

- `byteValue()`
- `shortValue()`
- `intValue()`
- `longValue()`
- `floatValue()`
- `doubleValue()`

Таким образом, вы можете создать объект, например, `Integer`, и затем извлечь его значение в любом другом примитивном числовом формате с помощью соответствующего метода.
