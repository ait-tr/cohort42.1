## Ветвления в Git

Ветвление в Git позволяет разработчикам изолированно работать над новыми функциями или исправлениями, не влияя на основную кодовую базу.
Это ключевая особенность, которая делает Git мощным инструментом для командной разработки.

### Fork

**Fork** - это клон репозитория со всей историей и состоянием на момент его создания. При этом сохраняется связь с оригинальным репозиторием 
и можно по желанию синхронизировать данные оттуда со своим форком или делать **pull requests** в оригинальный репозиторий.
При этом изменения в форке никак не отражаются на оригинале.

Как правило, форки используются для подготовки изменений в оригинал: вы не можете создать ответвление в оригинальной версии, 
так как у нее другой владелец (не вы) — для этого вам надо сначала сделать себе копию, в копии сделать изменения и только потом 
предложить владельцу оригинала применить их у себя.

Иногда форки используются чтобы создать отдельную `ветвь`, которая кардинальным образом будет отличаться от оригинала: 
например, когда у вас соверешенное иное видение того, как должен выглядеть проект, и вы хотите переписать его.

### Pull request

**Pull request** — предложение изменения кода в чужом репозитории. Вы делаете форк чужого репозитория (который иногда и сам может быть форком),
затем производите изменения в своём форке, затем посредством pull request предлагаете изменения владельцам репозитория, чей форк Вы сделали. 
На GitHub pull request в публичный репозиторий может осуществить любая/ой зарегистрированная/ый участница/участник.

**Разновидности pull requests**

Все pull requests можно разделить на следующие категории:
- Исправление багов, ошибок, конфликтов с другими приложениями
- Добавление новых функций, возможностей
- Рефакторинг, стилевые правки. Если владелица/владелец репозитория не хуже Вас разбирается в коде репозитория, 
  лучше не злоупотреблять pull requests данной категории.

Подробнее в статье: [Pull request'ы на GitHub или Как мне внести изменения в чужой проект](https://habr.com/ru/articles/125999/)

### Основы ветвления в Git

**Ветки** в Git — это просто указатели на определенные коммиты.
Когда вы создаете новую ветку, Git создает новый указатель, который можно перемещать независимо от других веток.

- **`master` или `main` ветка**: Традиционно основная ветка, где хранится стабильная версия проекта.
- **Функциональные ветки (Feature branches)**: Используются для разработки новых функций или исправлений, обычно одна ветка на функцию или исправление.
- **Ветки исправлений (Hotfix branches)**: Для срочных исправлений в основной кодовой базе.

### git branch

Работа с ветками в репозитории

- `git branch` - показывает список веток
- `git branch branch-name` - создает новую ветку branch-name
- `git branch -D branch-name` — удаляет ветку branch-name
- `git checkout` - Переключается на другую ветку
- `git checkout branch-name` — переключается на последний коммит в ветке branch-name
- `git checkout -b branch-name` - создает и переключается на ветку branch-name

Переименование ветки в Git зависит от того, находитесь ли вы в этой ветке или хотите переименовать другую ветку.

- `git branch -m new-branch-name` - переименование текущей ветки
- `git branch -m old-branch-name new-branch-name` - переименовать ветку, находясь в другой ветке
- `git push origin -u branch-name` - Отправить новую ветку в удалённый репозиторий и установите её как upstream
- `git push origin --delete branch-name` - Удалить ветку из удалённого репозитория

--- 

## Модели совместной разработки

Разберем две основные модели совместной разработки в контексте использования Git и GitHub (или аналогичных систем управления версиями и платформ):
- **модель с общим репозиторием** (Shared-repository model)
- **модель с форками и пулл-реквестами** (Forks and Pull Requests model).

Обе модели имеют свои преимущества и недостатки и подходят для разных сценариев работы.

### 1. Модель с общим репозиторием (Shared-repo model)

В этой модели все участники команды имеют прямой доступ на запись в один общий репозиторий. Они могут клонировать репозиторий, создавать новые ветки, делать коммиты и пушить изменения напрямую в общий репозиторий.

**Когда лучше использовать:**
- В небольших командах, где все разработчики знакомы друг с другом и доверяют друг другу.
- В приватных проектах или организациях, где управление доступом строго контролируется.
- Когда нужна простота управления и меньше оверхеда с настройкой доступов.

**Преимущества:**
- Простота и быстрота внесения изменений, не требуется создавать форки.
- Удобно для небольших команд, где требуется тесное взаимодействие и быстрая итерация.

**Недостатки:**
- Больший риск случайного повреждения основной ветки (`main` или `master`), особенно без строгих правил ревью кода.
- Требуется доверие между всеми участниками команды, так как каждый имеет полный доступ.

### 2. Модель с форками и пулл-реквестами (Forks and Pull Requests model)

В этой модели участники не имеют прямого доступа на запись в основной репозиторий.
Вместо этого они создают свои собственные копии (форки) репозитория, работают в этих форках, а затем предлагают свои изменения через пулл-реквесты.

**Когда лучше использовать:**
- В проектах с открытым исходным кодом, где участвует широкий круг незнакомых разработчиков.
- Когда необходим строгий контроль над изменениями в основном репозитории.
- Для обеспечения код-ревью и обсуждения изменений перед их внедрением.

**Преимущества:**
- Высокий уровень контроля за качеством и безопасностью кода.
- Возможность широкого обсуждения и рецензирования изменений перед их принятием.
- Безопасность основного репозитория от случайных повреждений.

**Недостатки:**
- Больше шагов для внесения изменений (нужно создать форк, поддерживать его в актуальном состоянии, создавать пулл-реквесты).
- Может быть менее удобно для небольших команд или проектов, где все разработчики доверяют друг другу и хорошо знакомы с процессами.

В целом, выбор между этими моделями зависит от размера команды, типа проекта (открытый или закрытый), необходимости контроля над изменениями и предпочтений в работе.

---

### Общий порядок (схема) работы в режиме с доступом на запись

1. Открыть имеющийся репо (или создать новый)
2. Добавить членов команды
3. Настройка защиты ветки `main`
4. Клонировать репо (скачать на компьютер)
5. Открыть репо в любимом редакторе
6. Создать отдельную ветку под задачу
    - `git checkout -b new-branch-name`
    - `git checkout -b sergey/create-hello-file`
7. Решаем задачу (вносим правки в проект)
8. Фиксация изменений
    - `git add .`
    - `git commit -m 'update'`
9. Выгрузить ветку (изменения) на GitHub
    - `git push -u origin ветка`
10. Оформить “заявку на улучшение” (Pull Request, PR, запрос на слияние)
11. **(доп/шаг)** Выгрузить изменения с GitHub себе на компьютер
    1. переключиться на `main`
    2. `git pull`
