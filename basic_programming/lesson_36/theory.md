## Интерфейс Map

Интерфейс `Map` в Java представляет собой структуру данных для хранения пар "ключ-значение".
Каждый ключ в `Map` уникален, и каждому ключу соответствует ровно одно значение. `Map` не является наследником интерфейса `Collection`.

### Особенности интерфейса `Map`:

- **Не является коллекцией:** `Map` не наследуется от интерфейса `Collection` и поэтому имеет уникальный API, отличный от других коллекций.
- **Уникальные ключи:** Каждый ключ в `Map` должен быть уникальным, и попытка вставить дублирующийся ключ приведёт к замене старого значения новым.
- **Один `null` ключ:** Большинство реализаций `Map` (за исключением `Hashtable` и подобных) допускают использование `null` в качестве ключа, но только для одного элемента.
- **Множественные `null` значения:** `Map` может содержать несколько пар "ключ-значение", где значения являются `null`.

### Особенности использования интерфейса `Map`:

- **Доступ по ключу:** `Map` предоставляет быстрый доступ к значениям по ключам.
- **Изменяемость:** В отличие от коллекций, которые хранят отдельные элементы, `Map` позволяет изменять значения, связанные с конкретными ключами.
- **Порядок элементов:** `HashMap` не гарантирует порядок элементов, `LinkedHashMap` сохраняет порядок вставки или порядок доступа, `TreeMap` обеспечивает сортировку по ключам.
- **Подклассы и поведение:** Подклассы `Map`, такие как `TreeMap` и `ConcurrentHashMap`, предоставляют специальное поведение, например, упорядоченность или многопоточную поддержку.

### Основные методы интерфейса Map:

- `void clear()`: очищает карту.
- `boolean containsKey(Object key)`: возвращает `true`, если карта содержит указанный ключ.
- `boolean containsValue(Object value)`: возвращает `true`, если карта содержит одно или несколько значений.
- `Set<Map.Entry<K,V>> entrySet()`: возвращает `Set` представлений всех пар "ключ-значение" карты.
- `boolean equals(Object o)`: сравнивает указанный объект с картой на равенство.
- `V get(Object key)`: возвращает значение, соответствующее указанному ключу, или `null`, если такого ключа нет.
- `V getOrDefault(Object key, V defaultValue)`: возвращает значение, соответствующее указанному ключу, или `defaultValue`, если такого ключа нет в карте.
- `int hashCode()`: возвращает хеш-код для карты.
- `boolean isEmpty()`: возвращает `true`, если карта пуста.
- `Set<K> keySet()`: возвращает `Set` всех ключей карты.
- `V put(K key, V value)`: ассоциирует указанное значение с указанным ключом в карте.
- `void putAll(Map<? extends K, ? extends V> m)`: копирует все пары "ключ-значение" из указанной карты в текущую.
- `V remove(Object key)`: удаляет пару "ключ-значение" по указанному ключу.
- `int size()`: возвращает количество пар "ключ-значение" в карте.
- `Collection<V> values()`: возвращает `Collection` всех значений карты.

### Реализации интерфейса Map и их отличия:

- **HashMap**:
    - Не гарантирует порядок элементов.
    - Позволяет `null` в качестве ключа и значения.
    - Операции вставки и доступа имеют константную временную сложность в идеальных условиях.

- **LinkedHashMap**:
    - Расширяет `HashMap`, сохраняя связный список записей в порядке их добавления или в порядке доступа (если это указано при создании).
    - Подходит для создания кэшей, где важен порядок элементов.

- **TreeMap**:
  - Реализует отсортированное навигационное дерево.
  - Гарантирует, что элементы будут в порядке возрастания ключей.
  - Позволяет извлекать части карты (например, `headMap`, `tailMap`, `subMap`).
  - Операции доступа имеют временную сложность `O(log n)`.

- **Hashtable**:
    - Предшественник `HashMap`, но синхронизирован и не допускает `null` в качестве ключа или значения.
    - Устарела из-за низкой производительности в многопоточных приложениях.

- **ConcurrentHashMap**:
    - Предназначен для использования в многопоточных приложениях.
    - Позволяет конкурентный доступ и обновления без полной блокировки карты.
    - Не допускает `null` в качестве ключа или значения.

- **EnumMap** — это специализированная реализация интерфейса `Map`, предназначенная исключительно для использования с ключами типа перечисления (`enum`). `EnumMap` хранит элементы в массиве и использует порядковый номер `enum` в качестве индекса, что обеспечивает отличную производительность операций.
    - **Ключи-перечисления:** Все ключи должны быть элементами одного и того же `enum` типа.
    - **Порядок элементов:** Элементы в `EnumMap` хранятся в естественном порядке их объявления в `enum` типе.
    - **Производительность:** Операции доступа, вставки и удаления выполняются очень быстро благодаря использованию массива и порядковых номеров `enum`.
    - **Null значения:** `EnumMap` допускает использование `null` в качестве значения, но не в качестве ключа.
    - **Итераторы:** Итераторы возвращаемые `EnumMap` не выбрасывают `ConcurrentModificationException`, и поэтому `EnumMap` не подходит для использования в многопоточных средах, где карта может изменяться другими потоками.
    - **Специализированное использование:** `EnumMap` является хорошим выбором, когда ключи являются перечислениями, так как это обеспечивает лучшую производительность и компактное использование памяти по сравнению с `HashMap`.

### Примеры использования интерфейса `Map`:

- **Хранение связей:** Когда необходимо хранить связи типа "ключ-значение", например, идентификаторы пользователей и их данные.
- **Уникальность ключей:** Когда нужно гарантировать, что каждый ключ в коллекции уникален.
- **Поиск:** Когда часто требуется поиск элементов, `Map` обеспечивает эффективный доступ по ключу.
- **В качестве кэша:** `LinkedHashMap` часто используется для реализации LRU кэшей.
- **Конкурентные коллекции:** `ConcurrentHashMap` используется в многопоточных приложениях для предотвращения блокировок и улучшения производительности.

### Примечание по использованию:

- **Ключи:** Идеально подходящими ключами для `Map` являются **неизменяемые классы**, которые правильно реализуют `equals()` и `hashCode()` (например, строки или числа).
- **Производительность:** Надо помнить, что хеш-карты (`HashMap`, `ConcurrentHashMap`) быстрее для операций поиска, вставки и удаления в сравнении с древовидной реализацией (`TreeMap`), которая обеспечивает упорядоченность элементов.

Выбор реализации `Map` зависит от конкретных требований и контекста использования. Например, если важен порядок элементов, стоит рассмотреть `LinkedHashMap` или `TreeMap`. Если вы работаете в многопоточной среде, `ConcurrentHashMap` будет лучшим выбором.

---

<img src="https://raw.githubusercontent.com/ait-tr/cohort42.1/main/basic_programming/lesson_36/img/CollectionSB_N.jpeg" width="100%">

---

### EnumSet

`EnumSet` — это специализированная реализация интерфейса `Set` для использования исключительно с перечислениями (`enum`). Она представляет собой высокоэффективную и компактную структуру данных для `enum` типов. `EnumSet` использует битовые векторы для представления множеств, что делает операции над ними очень быстрыми.

Поскольку `EnumSet` не использует хэш-коды, как `HashSet`, операции вставки, удаления и проверки наличия элементов выполняются очень быстро, практически за константное время. Кроме того, итераторы, возвращаемые `EnumSet`, не выдают `ConcurrentModificationException` и могут использоваться безопасно даже при изменении множества.

Основные особенности `EnumSet`:

- Элементы автоматически упорядочены в порядке, в котором объявлены `enum` константы.
- `null` элементы не допускаются.

Вот несколько ключевых особенностей и сценариев использования `EnumSet`:

- **Производительность**: `EnumSet` основан на использовании битовых векторов, что делает операции такие как добавление, удаление и проверка на вхождение очень быстрыми, близкими к выполнению за константное время.
- **Компактное хранение**: Поскольку `enum` имеет фиксированный набор возможных значений, `EnumSet` может использовать биты для представления присутствия или отсутствия каждого элемента, что делает его очень эффективным по памяти.
- **Специализированные методы**: `EnumSet` предлагает методы для создания диапазонов (например, `range(E from, E to)`), которые позволяют создавать наборы, содержащие все элементы перечисления в определенном диапазоне.
- **Предсказуемый порядок итерации**: `EnumSet` гарантирует, что итератор проходит элементы в порядке, в котором они объявлены в `enum`. Это может быть полезно для алгоритмов, которым важен порядок элементов.
- **Безопасность типов**: `EnumSet` гарантирует, что в наборе могут быть только элементы одного `enum` типа, что предотвращает ошибки, связанные с неверным типом элементов.

`EnumSet` в Java предоставляет несколько уникальных статических методов, которые оптимизированы для работы с элементами перечисления (`enum`). Вот основные из них:

- **allOf(Class<E> elementType)**:
  Создаёт `EnumSet`, содержащий все элементы указанного элементного типа `enum`.
- **noneOf(Class<E> elementType)**:
  Создаёт пустой `EnumSet` для указанного элементного типа `enum`.
- **of(E first, E... rest)**:
  Создаёт `EnumSet`, содержащий указанный первый элемент и необязательно последующие элементы.
  - **of(E e)**:
    Создаёт `EnumSet`, содержащий один указанный элемент.
  - **of(E e1, E e2)**, **of(E e1, E e2, E e3)** и так далее до **of(E e1, E e2, E e3, E e4, E e5)**:
    Создаёт `EnumSet`, содержащий от двух до пяти указанных элементов (перегрузки для определенного числа элементов).
- **range(E from, E to)**: 
  Создаёт `EnumSet`, содержащий все элементы перечисления в диапазоне от `from` до `to` (включительно).
- **copyOf(EnumSet<E> s)**:
  Создаёт копию существующего `EnumSet`.
- **copyOf(Collection<E> c)**:
  Создаёт `EnumSet`, содержащий все элементы указанной коллекции. Если коллекция `c` также является `EnumSet`, этот метод ведёт себя идентично методу `copyOf(EnumSet<E> s)`.
- **complementOf(EnumSet<E> s)**:
  Создаёт `EnumSet`, содержащий все элементы типа элементов указанного `EnumSet`, которые не присутствуют в самом `s` (то есть дополнение `s`).

Эти методы позволяют легко и эффективно создавать и манипулировать `EnumSet`, что делает его идеальным выбором для работы с наборами перечислений.

Пример использования `EnumSet`:

```
// Пример перечисления
public enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}

public class EnumSetExample {
    public static void main(String[] args) {
        // Создание EnumSet со всеми элементами
        EnumSet<Day> daysOff = EnumSet.allOf(Day.class);

        // Удаление элементов
        daysOff.remove(Day.MONDAY);
        daysOff.remove(Day.TUESDAY);

        // Создание EnumSet с частью элементов
        EnumSet<Day> weekend = EnumSet.of(Day.SATURDAY, Day.SUNDAY);

        // Создание EnumSet с диапазоном элементов
        EnumSet<Day> workDays = EnumSet.range(Day.MONDAY, Day.FRIDAY);

       
        // Объединение двух EnumSet
        EnumSet<Day> allDays = EnumSet.copyOf(daysOff);
        allDays.addAll(weekend);
    }
}
```

`EnumSet` является предпочтительным выбором, когда нужно работать с множеством элементов перечисляемого типа, так как она обеспечивает лучшую производительность по сравнению с обычными `HashSet` или `TreeSet`.
