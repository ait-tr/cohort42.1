## Полиморфизм

**Полиморфизм** - один из принципов объектно-ориентированного программирования (ООП) наряду с инкапсуляцией и наследованием. 
Это понятие происходит от греческих слов: "поли" (много) и "морф" (форма), и, действительно, **полиморфизм позволяет объектам принимать множество форм**.

А дальше, как говорится, "возможны варианты".
Существует множество определений для явления полиморфизма. Включая очень мудреные и не понятных, даже после 5го прочтения этого определения.

**Полиморфизм** — это концепция объектно-ориентированного программирования (ООП), которая позволяет рассматривать объекты разных классов как объекты общего класса. 
В Java полиморфизм означает, что метод может иметь несколько реализаций в зависимости от типа объекта, с которым выполняется операция.

**Полиморфизмом** называется возможность работать с несколькими типами так, как будто это один и тот же тип и в то же время поведение каждого типа будет 
уникальным в зависимости от его реализации.

**Полиморфизм** — одна из фундаментальных концепций объектно-ориентированного программирования.

Полиморфизм позволяет рассматривать объекты как объекты их базового класса, что позволяет писать общий код, делая его более гибким и пригодным для 
повторного использования. Это позволяет создавать многоразовый и удобный в сопровождении код, а также повышает читаемость кода.

- **Статический полиморфизм (компиляционный)**: реализуется с помощью перегрузки методов. Компилятор определяет, какой метод нужно вызывать на основе 
объявления метода (имя метода и список параметров).

- **Динамический полиморфизм (времени выполнения)**: реализуется с помощью переопределения методов. Время выполнения (JVM) определяет, какой метод вызывать 
на основе фактического объекта, на котором вызывается метод.

"Динамический полиморфизм" (полиморфизм времени выполнения, который реализуется через переопределение методов) часто называется "истинным полиморфизмом". 
Это потому, что во время выполнения решение о том, какой метод вызвать, принимается на основе реального типа объекта, что и является ключевой особенностью 
полиморфизма в объектно-ориентированном программировании.

---

Да, полиморфизм - это точно про гибкость. Основной механизм в Java, делающий наш код гибким.

Т.к. класс содержит все методы класса, от которого он был унаследован, то объект этого класса можно сохранить в переменную любого из его типов родителей.

Если в результате присваивания мы двигаемся по цепочке наследования вверх (к типу Object), то это — расширение типа (оно же — восходящее преобразование или 
upcasting), а если вниз, к типу объекта, то это — сужение типа (оно же — нисходящее преобразование или down-casting).

---

## Класс Object

Класс `Object` в Java занимает особое место в иерархии классов языка программирования Java. Он является корнем иерархии классов в Java, что означает, 
что любой другой класс неявно наследуется от класса `Object`, если только не указано иное. Это обеспечивает базовую функциональность для всех объектов 
в Java и является основой для реализации полиморфизма.

### Наследование и Класс Object

Когда класс не расширяет явно другой класс, он неявно наследуется от класса `Object`. Это означает, что любой объект в Java наследует базовые методы 
класса `Object`, которые могут быть переопределены для изменения их поведения в подклассах. Наследование от `Object` обеспечивает общий тип для всех 
объектов и позволяет использовать любой объект в Java там, где ожидается `Object`.

### Полиморфизм и Класс Object

Полиморфизм в Java позволяет одной и той же переменной ссылочного типа указывать на объекты различных типов. Благодаря тому, что все классы наследуются 
от `Object`, переменную типа `Object` можно использовать для ссылки на любой объект независимо от его конкретного класса. Это позволяет, например, 
хранить в коллекциях объекты различных типов, поскольку все они являются наследниками класса `Object`.

### Основные Методы Класса Object

Класс `Object` предоставляет несколько методов, которые имеют большое значение для работы с объектами в Java:

- **`equals(Object obj)`**: Определяет, равен ли текущий объект другому объекту. Метод можно переопределить в подклассах для реализации сравнения объектов по значению.
- **`hashCode()`**: Возвращает хеш-код объекта, который используется в коллекциях, таких как `HashMap`. Переопределение этого метода важно при изменении поведения метода `equals`, чтобы поддерживать контракт между `equals` и `hashCode`.
- **`toString()`**: Возвращает строковое представление объекта. Часто переопределяется в подклассах для предоставления более информативного описания объекта.
- **`clone()`**: Создаёт и возвращает копию объекта. Чтобы использовать этот метод, класс должен реализовать интерфейс `Cloneable`.
- **`getClass()`**: Возвращает объект `Class`, который представляет класс выполнения объекта. Этот метод может быть использован для получения метаинформации о классе.
- **`finalize()`**: Вызывается сборщиком мусора перед удалением объекта. Этот метод может быть переопределён для реализации очистки ресурсов перед уничтожением объекта, но его использование не рекомендуется из-за непредсказуемости работы сборщика мусора.

Все методы в [документации](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html).

Наследование от класса `Object` в Java гарантирует, что методы, определённые в классе `Object`, доступны во всех классах, даже если эти классы являются 
пользовательскими или частью Java API. Это означает, что каждый объект в Java наследует базовый набор методов, который может быть использован для выполнения 
фундаментальных операций, таких как сравнение объектов, получение хеш-кода объекта, получение строкового представления объекта и других.

### Наследование и Универсальность Методов

Благодаря наследованию от класса `Object`, мы имеем уверенность в том, что любой объект в Java будет обладать определённым базовым поведением. 
Это делает объекты в Java взаимозаменяемыми в контекстах, где ожидается тип `Object`, и обеспечивает базовую функциональность для любого типа объектов.

### Полиморфизм и Переопределение Методов

Полиморфизм в Java позволяет классам переопределить (override) методы, унаследованные от класса `Object`, для предоставления специфичного для класса поведения. 
Например, переопределяя метод `equals()`, можно определить, когда два объекта считаются равными на основе их содержимого, а не идентичности ссылок. 
Аналогично, переопределение `toString()` позволяет возвращать строковое представление объекта, которое может быть более информативным и понятным для человека.

Переопределение методов класса `Object` обеспечивает два важных аспекта полиморфизма:
- **Время компиляции**: Компилятор Java позволяет переопределить методы, гарантируя, что подклассы могут предоставлять собственную реализацию для 
унаследованных методов.
- **Время выполнения**: Виртуальная машина Java (JVM) во время выполнения определяет, какая версия метода должна быть вызвана на основе 
фактического типа объекта, что позволяет одной и той же ссылке вызывать различные реализации методов в зависимости от типа объекта, на который она указывает.

### Заключение

Таким образом, наличие методов класса `Object` во всех классах Java и возможность их переопределения являются фундаментальными аспектами 
объектно-ориентированного программирования в Java. Это обеспечивает универсальность и гибкость при работе с объектами различных типов, 
позволяя разработчикам модифицировать или расширять базовое поведение объектов для соответствия специфическим требованиям их программ.
